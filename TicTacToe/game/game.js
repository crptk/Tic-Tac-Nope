document.addEventListener("DOMContentLoaded", () => {
    console.log("Script loaded")
    let gameArray = [
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]
    ];
    let gameOver = false; // Flag to track if the game is over
    let isPlayerTurn = true; // Flag to track if it's the player's turn
    let filledCells = 0; // Counter for filled cells


    const cells = document.querySelectorAll(".cell");
    const imgs = document.querySelectorAll("img");

    const highlightWinningCells = (indices, color) => {
        indices.forEach(index => {
            cells[index].style.backgroundColor = color;
        });
    };
    operations = 0;
    // Minimax function to evaluate the best move for the AI (THIS FUNCTION AND THE CHECKWINNER FUNCTION WAS GENERATED BY CHATGPT)
    function minimax(gameArray, depth, isMaximizing) {
        operations += 1;
        // Base cases: check if someone has won or if it's a tie
        const winner = checkWinner(); 
        if (winner === 2) return 10 - depth; // AI wins
        if (winner === 1) return depth - 10; // Player wins
        if (filledCells === 9) return 0; // It's a tie

        if (isMaximizing) {
            // Maximizing for AI
            let bestScore = -Infinity;
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    if (gameArray[row][col] === 0) {
                        gameArray[row][col] = 2; // AI makes a move
                        filledCells++;
                        let score = minimax(gameArray, depth + 1, false); // Recurse with minimizing player
                        gameArray[row][col] = 0; // Undo the move
                        filledCells--;
                        bestScore = Math.max(score, bestScore);
                    }
                }
            }
            return bestScore;
        } else {
            // Minimizing for the player
            let bestScore = Infinity;
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    if (gameArray[row][col] === 0) {
                        gameArray[row][col] = 1; // Player makes a move
                        filledCells++;
                        let score = minimax(gameArray, depth + 1, true); // Recurse with maximizing player
                        gameArray[row][col] = 0; // Undo the move
                        filledCells--;
                        bestScore = Math.min(score, bestScore);
                    }
                }
            }
            return bestScore;
        }
    }

    // Helper function to check the winner (exclusively for Minimiax Algorithm) (GENERATED BY CHATGPT)
    function checkWinner() {
        // Check rows, columns, and diagonals for a winner
        for (let row = 0; row < 3; row++) {
            if (gameArray[row][0] === gameArray[row][1] && gameArray[row][1] === gameArray[row][2] && gameArray[row][0] !== 0) {
                return gameArray[row][0];
            }
        }
        for (let col = 0; col < 3; col++) {
            if (gameArray[0][col] === gameArray[1][col] && gameArray[1][col] === gameArray[2][col] && gameArray[0][col] !== 0) {
                return gameArray[0][col];
            }
        }
        if (gameArray[0][0] === gameArray[1][1] && gameArray[1][1] === gameArray[2][2] && gameArray[0][0] !== 0) {
            return gameArray[0][0];
        }
        if (gameArray[0][2] === gameArray[1][1] && gameArray[1][1] === gameArray[2][0] && gameArray[0][2] !== 0) {
            return gameArray[0][2];
        }
        return null; // No winner yet
    }

    // For checking win condition (checks for the game as a whole)
    const checkWinCondition = (player, row, col) => {
        //IF the current player's placement aligns with a win
        if (
            (gameArray[row][0] === player && gameArray[row][1] === player && gameArray[row][2] === player) ||
            (gameArray[0][col] === player && gameArray[1][col] === player && gameArray[2][col] === player) ||
            (gameArray[0][0] === player && gameArray[1][1] === player && gameArray[2][2] === player) ||
            (gameArray[0][2] === player && gameArray[1][1] === player && gameArray[2][0] === player)
        ) { //Then create a winningCells array that inserts all the winning cells inside
            const winningCells = [];
            if (gameArray[row][0] === player && gameArray[row][1] === player && gameArray[row][2] === player) {
                winningCells.push(row * 3, row * 3 + 1, row * 3 + 2);
            } else if (gameArray[0][col] === player && gameArray[1][col] === player && gameArray[2][col] === player) {
                winningCells.push(col, col + 3, col + 6);
            } else if (gameArray[0][0] === player && gameArray[1][1] === player && gameArray[2][2] === player) {
                winningCells.push(0, 4, 8);
            } else if (gameArray[0][2] === player && gameArray[1][1] === player && gameArray[2][0] === player) {
                winningCells.push(2, 4, 6);
            }
            //If player is 1, will highlight green, otherwise it will highlight red
            highlightWinningCells(winningCells, player === 1 ? "green" : "red");
            console.log(`Player ${player} wins!`); //`` is basically like f' string from Python
            document.getElementById("turn").textContent = `Player ${player} wins!`;
            gameOver = true;
            return true;
        }
        return false;
    };

    const checkTieCondition = () => {
        if (filledCells === 9 && !gameOver) {
            console.log("It's a tie!");
            document.getElementById("turn").textContent = "It's a tie!";
            gameOver = true; // Ensure game stops after tie is detected
        }
    };

    document.getElementById("turn").textContent = "Player 1 turn!"; // Set initial turn

    const handlePlayerMove = (cell, row, col) => {
        gameArray[row][col] = 1;
        filledCells++;
        const X = document.createElement('img');
        X.src = "img/X.png";
        X.alt = "X";
        cell.appendChild(X);

        if (checkWinCondition(1, row, col)) return true;

        checkTieCondition(); // Check for a tie after player move

        if (!gameOver) {
            document.getElementById("turn").textContent = "Player 2 turn!";
            isPlayerTurn = false; // Switch to AI turn
        }
        return false;
    };

    // Originally made by me, but modified by ChatGPT to integrate minimax algorithm
    const handleAIMove = () => {
        setTimeout(() => {
            if (gameOver) return; // Prevent AI from moving after game is over
    
            let bestScore = -Infinity;
            let bestMove = { row: null, col: null };
            
            //Iterate through every tile
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    if (gameArray[row][col] === 0) {
                        // Try the move
                        gameArray[row][col] = 2;
                        filledCells++;
                        let score = minimax(gameArray, 0, false); // Call minimax for AI
                        gameArray[row][col] = 0; // Undo the move
                        filledCells--;
    
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = { row, col };
                        }
                    }
                }
            }
            console.log("Operations:", operations);
            operations = 0;
    
            // AI makes the best move
            if (bestMove.row !== null && bestMove.col !== null) {
                gameArray[bestMove.row][bestMove.col] = 2;
                filledCells++;
                const O = document.createElement("img");
                O.src = "img/O.png";
                O.alt = "O";
                cells[bestMove.row * 3 + bestMove.col].appendChild(O);
    
                if (checkWinCondition(2, bestMove.row, bestMove.col)) {
                    gameOver = true;
                } else {
                    checkTieCondition(); // Check for a tie after AI move
                    if (!gameOver) {
                        document.getElementById("turn").textContent = "Player 1 turn!";
                        isPlayerTurn = true; // Switch back to player turn
                    }
                }
            }
        }, 500); // 500ms delay
    };
    

    cells.forEach((cell, index) => {
        cell.addEventListener('click', () => {
            if (gameOver || !isPlayerTurn) return;

            const row = Math.floor(index / 3);
            const col = index % 3;

            if (gameArray[row][col] !== 0) {
                console.log("That tile is taken!");
                return;
            }

            if (handlePlayerMove(cell, row, col)) return;

            if (!gameOver) {
                handleAIMove();
            }
        });
    });
    function buttonReset()
    {
        // Reset the game array
        gameArray = [
            [0, 0, 0],
            [0, 0, 0],
            [0, 0, 0]
        ];

        // Reset the filled cells counter and flags
        filledCells = 0;
        gameOver = false;
        isPlayerTurn = true;

        // Reset the cell backgrounds and remove images
        cells.forEach(cell => {
            cell.style.backgroundColor = "transparent";
            while (cell.firstChild) //removes all child elements by constantly checking if it has a "first" child element
            {
                cell.removeChild(cell.firstChild)
            }
        })
        document.getElementById("turn").textContent = "Player 1 turn!";
    }
    function returnHome() {
        window.location.href = "../homepage/homepage.html"
    }
    const homeButton = document.querySelector('#home');
    if (homeButton) {
        homeButton.addEventListener('click', returnHome);
    }

    const resetButton = document.querySelector('#reset');
    if (resetButton) {
        resetButton.addEventListener('click', buttonReset);
    }

});
